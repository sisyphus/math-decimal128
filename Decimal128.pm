## This file generated by InlineX::C2XS (version 0.22) using Inline::C (version 0.5501)
package Math::Decimal128;

use 5.006;

use warnings;
use strict;

require Exporter;
*import = \&Exporter::import;
require DynaLoader;

$Math::Decimal128::VERSION = '0.02';

use subs qw(DEC128_MAX DEC128_MIN);

use overload
  '+'     => \&_overload_add,
  '*'     => \&_overload_mul,
  '-'     => \&_overload_sub,
  '/'     => \&_overload_div,
  '+='    => \&_overload_add_eq,
  '*='    => \&_overload_mul_eq,
  '-='    => \&_overload_sub_eq,
  '/='    => \&_overload_div_eq,
  '""'    => \&_overload_string,
  '=='    => \&_overload_equiv,
  '!='    => \&_overload_not_equiv,
  '<'     => \&_overload_lt,
  '>'     => \&_overload_gt,
  '<='    => \&_overload_lte,
  '>='    => \&_overload_gte,
  '<=>'   => \&_overload_spaceship,
  '='     => \&_overload_copy,
  '!'     => \&_overload_not,
  'bool'  => \&_overload_true,
  'abs'   => \&_overload_abs,
  '++'    => \&_overload_inc,
  '--'    => \&_overload_dec,
  'int'   => \&_overload_int,
;

DynaLoader::bootstrap Math::Decimal128 $Math::Decimal128::VERSION;

@Math::Decimal128::EXPORT = ();
@Math::Decimal128::EXPORT_OK = qw(
    NaND128 InfD128 ZeroD128 UnityD128 Exp10l NVtoD128 UVtoD128 IVtoD128 PVtoD128 STRtoD128
    have_strtod128 D128toNV assignNaNl assignInfl D128toME DPDtoD128
    D128toD128 D128toD128 is_NaND128 is_InfD128 is_ZeroD128 DEC128_MAX DEC128_MIN
    assignMEl d128_bytes MEtoD128 hex2binl decode_d128 decode_bidl decode_dpdl d128_fmt
    get_expl get_signl
    );

%Math::Decimal128::EXPORT_TAGS = (all => [qw(
    NaND128 InfD128 ZeroD128 UnityD128 Exp10l NVtoD128 UVtoD128 IVtoD128 PVtoD128 STRtoD128
    have_strtod128 D128toNV assignNaNl assignInfl D128toME DPDtoD128
    D128toD128 D128toD128 is_NaND128 is_InfD128 is_ZeroD128 DEC128_MAX DEC128_MIN
    assignMEl d128_bytes MEtoD128 hex2binl decode_d128 decode_bidl decode_dpdl d128_fmt
    get_expl get_signl
    )]);

%Math::Decimal128::dpd_encode = d128_fmt() eq 'DPD' ? (
     '0000000000' => '000', '0000000001' => '001', '0000000010' => '002', '0000000011' => '003',
     '0000000100' => '004', '0000000101' => '005', '0000000110' => '006', '0000000111' => '007',
     '0000001000' => '008', '0000001001' => '009', '0000010000' => '010', '0000010001' => '011',
     '0000010010' => '012', '0000010011' => '013', '0000010100' => '014', '0000010101' => '015',
     '0000010110' => '016', '0000010111' => '017', '0000011000' => '018', '0000011001' => '019',
     '0000100000' => '020', '0000100001' => '021', '0000100010' => '022', '0000100011' => '023',
     '0000100100' => '024', '0000100101' => '025', '0000100110' => '026', '0000100111' => '027',
     '0000101000' => '028', '0000101001' => '029', '0000110000' => '030', '0000110001' => '031',
     '0000110010' => '032', '0000110011' => '033', '0000110100' => '034', '0000110101' => '035',
     '0000110110' => '036', '0000110111' => '037', '0000111000' => '038', '0000111001' => '039',
     '0001000000' => '040', '0001000001' => '041', '0001000010' => '042', '0001000011' => '043',
     '0001000100' => '044', '0001000101' => '045', '0001000110' => '046', '0001000111' => '047',
     '0001001000' => '048', '0001001001' => '049', '0001010000' => '050', '0001010001' => '051',
     '0001010010' => '052', '0001010011' => '053', '0001010100' => '054', '0001010101' => '055',
     '0001010110' => '056', '0001010111' => '057', '0001011000' => '058', '0001011001' => '059',
     '0001100000' => '060', '0001100001' => '061', '0001100010' => '062', '0001100011' => '063',
     '0001100100' => '064', '0001100101' => '065', '0001100110' => '066', '0001100111' => '067',
     '0001101000' => '068', '0001101001' => '069', '0001110000' => '070', '0001110001' => '071',
     '0001110010' => '072', '0001110011' => '073', '0001110100' => '074', '0001110101' => '075',
     '0001110110' => '076', '0001110111' => '077', '0001111000' => '078', '0001111001' => '079',
     '0000001010' => '080', '0000001011' => '081', '0000101010' => '082', '0000101011' => '083',
     '0001001010' => '084', '0001001011' => '085', '0001101010' => '086', '0001101011' => '087',
     '0001001110' => '088', '0001001111' => '089', '0000011010' => '090', '0000011011' => '091',
     '0000111010' => '092', '0000111011' => '093', '0001011010' => '094', '0001011011' => '095',
     '0001111010' => '096', '0001111011' => '097', '0001011110' => '098', '0001011111' => '099',
     '0010000000' => '100', '0010000001' => '101', '0010000010' => '102', '0010000011' => '103',
     '0010000100' => '104', '0010000101' => '105', '0010000110' => '106', '0010000111' => '107',
     '0010001000' => '108', '0010001001' => '109', '0010010000' => '110', '0010010001' => '111',
     '0010010010' => '112', '0010010011' => '113', '0010010100' => '114', '0010010101' => '115',
     '0010010110' => '116', '0010010111' => '117', '0010011000' => '118', '0010011001' => '119',
     '0010100000' => '120', '0010100001' => '121', '0010100010' => '122', '0010100011' => '123',
     '0010100100' => '124', '0010100101' => '125', '0010100110' => '126', '0010100111' => '127',
     '0010101000' => '128', '0010101001' => '129', '0010110000' => '130', '0010110001' => '131',
     '0010110010' => '132', '0010110011' => '133', '0010110100' => '134', '0010110101' => '135',
     '0010110110' => '136', '0010110111' => '137', '0010111000' => '138', '0010111001' => '139',
     '0011000000' => '140', '0011000001' => '141', '0011000010' => '142', '0011000011' => '143',
     '0011000100' => '144', '0011000101' => '145', '0011000110' => '146', '0011000111' => '147',
     '0011001000' => '148', '0011001001' => '149', '0011010000' => '150', '0011010001' => '151',
     '0011010010' => '152', '0011010011' => '153', '0011010100' => '154', '0011010101' => '155',
     '0011010110' => '156', '0011010111' => '157', '0011011000' => '158', '0011011001' => '159',
     '0011100000' => '160', '0011100001' => '161', '0011100010' => '162', '0011100011' => '163',
     '0011100100' => '164', '0011100101' => '165', '0011100110' => '166', '0011100111' => '167',
     '0011101000' => '168', '0011101001' => '169', '0011110000' => '170', '0011110001' => '171',
     '0011110010' => '172', '0011110011' => '173', '0011110100' => '174', '0011110101' => '175',
     '0011110110' => '176', '0011110111' => '177', '0011111000' => '178', '0011111001' => '179',
     '0010001010' => '180', '0010001011' => '181', '0010101010' => '182', '0010101011' => '183',
     '0011001010' => '184', '0011001011' => '185', '0011101010' => '186', '0011101011' => '187',
     '0011001110' => '188', '0011001111' => '189', '0010011010' => '190', '0010011011' => '191',
     '0010111010' => '192', '0010111011' => '193', '0011011010' => '194', '0011011011' => '195',
     '0011111010' => '196', '0011111011' => '197', '0011011110' => '198', '0011011111' => '199',
     '0100000000' => '200', '0100000001' => '201', '0100000010' => '202', '0100000011' => '203',
     '0100000100' => '204', '0100000101' => '205', '0100000110' => '206', '0100000111' => '207',
     '0100001000' => '208', '0100001001' => '209', '0100010000' => '210', '0100010001' => '211',
     '0100010010' => '212', '0100010011' => '213', '0100010100' => '214', '0100010101' => '215',
     '0100010110' => '216', '0100010111' => '217', '0100011000' => '218', '0100011001' => '219',
     '0100100000' => '220', '0100100001' => '221', '0100100010' => '222', '0100100011' => '223',
     '0100100100' => '224', '0100100101' => '225', '0100100110' => '226', '0100100111' => '227',
     '0100101000' => '228', '0100101001' => '229', '0100110000' => '230', '0100110001' => '231',
     '0100110010' => '232', '0100110011' => '233', '0100110100' => '234', '0100110101' => '235',
     '0100110110' => '236', '0100110111' => '237', '0100111000' => '238', '0100111001' => '239',
     '0101000000' => '240', '0101000001' => '241', '0101000010' => '242', '0101000011' => '243',
     '0101000100' => '244', '0101000101' => '245', '0101000110' => '246', '0101000111' => '247',
     '0101001000' => '248', '0101001001' => '249', '0101010000' => '250', '0101010001' => '251',
     '0101010010' => '252', '0101010011' => '253', '0101010100' => '254', '0101010101' => '255',
     '0101010110' => '256', '0101010111' => '257', '0101011000' => '258', '0101011001' => '259',
     '0101100000' => '260', '0101100001' => '261', '0101100010' => '262', '0101100011' => '263',
     '0101100100' => '264', '0101100101' => '265', '0101100110' => '266', '0101100111' => '267',
     '0101101000' => '268', '0101101001' => '269', '0101110000' => '270', '0101110001' => '271',
     '0101110010' => '272', '0101110011' => '273', '0101110100' => '274', '0101110101' => '275',
     '0101110110' => '276', '0101110111' => '277', '0101111000' => '278', '0101111001' => '279',
     '0100001010' => '280', '0100001011' => '281', '0100101010' => '282', '0100101011' => '283',
     '0101001010' => '284', '0101001011' => '285', '0101101010' => '286', '0101101011' => '287',
     '0101001110' => '288', '0101001111' => '289', '0100011010' => '290', '0100011011' => '291',
     '0100111010' => '292', '0100111011' => '293', '0101011010' => '294', '0101011011' => '295',
     '0101111010' => '296', '0101111011' => '297', '0101011110' => '298', '0101011111' => '299',
     '0110000000' => '300', '0110000001' => '301', '0110000010' => '302', '0110000011' => '303',
     '0110000100' => '304', '0110000101' => '305', '0110000110' => '306', '0110000111' => '307',
     '0110001000' => '308', '0110001001' => '309', '0110010000' => '310', '0110010001' => '311',
     '0110010010' => '312', '0110010011' => '313', '0110010100' => '314', '0110010101' => '315',
     '0110010110' => '316', '0110010111' => '317', '0110011000' => '318', '0110011001' => '319',
     '0110100000' => '320', '0110100001' => '321', '0110100010' => '322', '0110100011' => '323',
     '0110100100' => '324', '0110100101' => '325', '0110100110' => '326', '0110100111' => '327',
     '0110101000' => '328', '0110101001' => '329', '0110110000' => '330', '0110110001' => '331',
     '0110110010' => '332', '0110110011' => '333', '0110110100' => '334', '0110110101' => '335',
     '0110110110' => '336', '0110110111' => '337', '0110111000' => '338', '0110111001' => '339',
     '0111000000' => '340', '0111000001' => '341', '0111000010' => '342', '0111000011' => '343',
     '0111000100' => '344', '0111000101' => '345', '0111000110' => '346', '0111000111' => '347',
     '0111001000' => '348', '0111001001' => '349', '0111010000' => '350', '0111010001' => '351',
     '0111010010' => '352', '0111010011' => '353', '0111010100' => '354', '0111010101' => '355',
     '0111010110' => '356', '0111010111' => '357', '0111011000' => '358', '0111011001' => '359',
     '0111100000' => '360', '0111100001' => '361', '0111100010' => '362', '0111100011' => '363',
     '0111100100' => '364', '0111100101' => '365', '0111100110' => '366', '0111100111' => '367',
     '0111101000' => '368', '0111101001' => '369', '0111110000' => '370', '0111110001' => '371',
     '0111110010' => '372', '0111110011' => '373', '0111110100' => '374', '0111110101' => '375',
     '0111110110' => '376', '0111110111' => '377', '0111111000' => '378', '0111111001' => '379',
     '0110001010' => '380', '0110001011' => '381', '0110101010' => '382', '0110101011' => '383',
     '0111001010' => '384', '0111001011' => '385', '0111101010' => '386', '0111101011' => '387',
     '0111001110' => '388', '0111001111' => '389', '0110011010' => '390', '0110011011' => '391',
     '0110111010' => '392', '0110111011' => '393', '0111011010' => '394', '0111011011' => '395',
     '0111111010' => '396', '0111111011' => '397', '0111011110' => '398', '0111011111' => '399',
     '1000000000' => '400', '1000000001' => '401', '1000000010' => '402', '1000000011' => '403',
     '1000000100' => '404', '1000000101' => '405', '1000000110' => '406', '1000000111' => '407',
     '1000001000' => '408', '1000001001' => '409', '1000010000' => '410', '1000010001' => '411',
     '1000010010' => '412', '1000010011' => '413', '1000010100' => '414', '1000010101' => '415',
     '1000010110' => '416', '1000010111' => '417', '1000011000' => '418', '1000011001' => '419',
     '1000100000' => '420', '1000100001' => '421', '1000100010' => '422', '1000100011' => '423',
     '1000100100' => '424', '1000100101' => '425', '1000100110' => '426', '1000100111' => '427',
     '1000101000' => '428', '1000101001' => '429', '1000110000' => '430', '1000110001' => '431',
     '1000110010' => '432', '1000110011' => '433', '1000110100' => '434', '1000110101' => '435',
     '1000110110' => '436', '1000110111' => '437', '1000111000' => '438', '1000111001' => '439',
     '1001000000' => '440', '1001000001' => '441', '1001000010' => '442', '1001000011' => '443',
     '1001000100' => '444', '1001000101' => '445', '1001000110' => '446', '1001000111' => '447',
     '1001001000' => '448', '1001001001' => '449', '1001010000' => '450', '1001010001' => '451',
     '1001010010' => '452', '1001010011' => '453', '1001010100' => '454', '1001010101' => '455',
     '1001010110' => '456', '1001010111' => '457', '1001011000' => '458', '1001011001' => '459',
     '1001100000' => '460', '1001100001' => '461', '1001100010' => '462', '1001100011' => '463',
     '1001100100' => '464', '1001100101' => '465', '1001100110' => '466', '1001100111' => '467',
     '1001101000' => '468', '1001101001' => '469', '1001110000' => '470', '1001110001' => '471',
     '1001110010' => '472', '1001110011' => '473', '1001110100' => '474', '1001110101' => '475',
     '1001110110' => '476', '1001110111' => '477', '1001111000' => '478', '1001111001' => '479',
     '1000001010' => '480', '1000001011' => '481', '1000101010' => '482', '1000101011' => '483',
     '1001001010' => '484', '1001001011' => '485', '1001101010' => '486', '1001101011' => '487',
     '1001001110' => '488', '1001001111' => '489', '1000011010' => '490', '1000011011' => '491',
     '1000111010' => '492', '1000111011' => '493', '1001011010' => '494', '1001011011' => '495',
     '1001111010' => '496', '1001111011' => '497', '1001011110' => '498', '1001011111' => '499',
     '1010000000' => '500', '1010000001' => '501', '1010000010' => '502', '1010000011' => '503',
     '1010000100' => '504', '1010000101' => '505', '1010000110' => '506', '1010000111' => '507',
     '1010001000' => '508', '1010001001' => '509', '1010010000' => '510', '1010010001' => '511',
     '1010010010' => '512', '1010010011' => '513', '1010010100' => '514', '1010010101' => '515',
     '1010010110' => '516', '1010010111' => '517', '1010011000' => '518', '1010011001' => '519',
     '1010100000' => '520', '1010100001' => '521', '1010100010' => '522', '1010100011' => '523',
     '1010100100' => '524', '1010100101' => '525', '1010100110' => '526', '1010100111' => '527',
     '1010101000' => '528', '1010101001' => '529', '1010110000' => '530', '1010110001' => '531',
     '1010110010' => '532', '1010110011' => '533', '1010110100' => '534', '1010110101' => '535',
     '1010110110' => '536', '1010110111' => '537', '1010111000' => '538', '1010111001' => '539',
     '1011000000' => '540', '1011000001' => '541', '1011000010' => '542', '1011000011' => '543',
     '1011000100' => '544', '1011000101' => '545', '1011000110' => '546', '1011000111' => '547',
     '1011001000' => '548', '1011001001' => '549', '1011010000' => '550', '1011010001' => '551',
     '1011010010' => '552', '1011010011' => '553', '1011010100' => '554', '1011010101' => '555',
     '1011010110' => '556', '1011010111' => '557', '1011011000' => '558', '1011011001' => '559',
     '1011100000' => '560', '1011100001' => '561', '1011100010' => '562', '1011100011' => '563',
     '1011100100' => '564', '1011100101' => '565', '1011100110' => '566', '1011100111' => '567',
     '1011101000' => '568', '1011101001' => '569', '1011110000' => '570', '1011110001' => '571',
     '1011110010' => '572', '1011110011' => '573', '1011110100' => '574', '1011110101' => '575',
     '1011110110' => '576', '1011110111' => '577', '1011111000' => '578', '1011111001' => '579',
     '1010001010' => '580', '1010001011' => '581', '1010101010' => '582', '1010101011' => '583',
     '1011001010' => '584', '1011001011' => '585', '1011101010' => '586', '1011101011' => '587',
     '1011001110' => '588', '1011001111' => '589', '1010011010' => '590', '1010011011' => '591',
     '1010111010' => '592', '1010111011' => '593', '1011011010' => '594', '1011011011' => '595',
     '1011111010' => '596', '1011111011' => '597', '1011011110' => '598', '1011011111' => '599',
     '1100000000' => '600', '1100000001' => '601', '1100000010' => '602', '1100000011' => '603',
     '1100000100' => '604', '1100000101' => '605', '1100000110' => '606', '1100000111' => '607',
     '1100001000' => '608', '1100001001' => '609', '1100010000' => '610', '1100010001' => '611',
     '1100010010' => '612', '1100010011' => '613', '1100010100' => '614', '1100010101' => '615',
     '1100010110' => '616', '1100010111' => '617', '1100011000' => '618', '1100011001' => '619',
     '1100100000' => '620', '1100100001' => '621', '1100100010' => '622', '1100100011' => '623',
     '1100100100' => '624', '1100100101' => '625', '1100100110' => '626', '1100100111' => '627',
     '1100101000' => '628', '1100101001' => '629', '1100110000' => '630', '1100110001' => '631',
     '1100110010' => '632', '1100110011' => '633', '1100110100' => '634', '1100110101' => '635',
     '1100110110' => '636', '1100110111' => '637', '1100111000' => '638', '1100111001' => '639',
     '1101000000' => '640', '1101000001' => '641', '1101000010' => '642', '1101000011' => '643',
     '1101000100' => '644', '1101000101' => '645', '1101000110' => '646', '1101000111' => '647',
     '1101001000' => '648', '1101001001' => '649', '1101010000' => '650', '1101010001' => '651',
     '1101010010' => '652', '1101010011' => '653', '1101010100' => '654', '1101010101' => '655',
     '1101010110' => '656', '1101010111' => '657', '1101011000' => '658', '1101011001' => '659',
     '1101100000' => '660', '1101100001' => '661', '1101100010' => '662', '1101100011' => '663',
     '1101100100' => '664', '1101100101' => '665', '1101100110' => '666', '1101100111' => '667',
     '1101101000' => '668', '1101101001' => '669', '1101110000' => '670', '1101110001' => '671',
     '1101110010' => '672', '1101110011' => '673', '1101110100' => '674', '1101110101' => '675',
     '1101110110' => '676', '1101110111' => '677', '1101111000' => '678', '1101111001' => '679',
     '1100001010' => '680', '1100001011' => '681', '1100101010' => '682', '1100101011' => '683',
     '1101001010' => '684', '1101001011' => '685', '1101101010' => '686', '1101101011' => '687',
     '1101001110' => '688', '1101001111' => '689', '1100011010' => '690', '1100011011' => '691',
     '1100111010' => '692', '1100111011' => '693', '1101011010' => '694', '1101011011' => '695',
     '1101111010' => '696', '1101111011' => '697', '1101011110' => '698', '1101011111' => '699',
     '1110000000' => '700', '1110000001' => '701', '1110000010' => '702', '1110000011' => '703',
     '1110000100' => '704', '1110000101' => '705', '1110000110' => '706', '1110000111' => '707',
     '1110001000' => '708', '1110001001' => '709', '1110010000' => '710', '1110010001' => '711',
     '1110010010' => '712', '1110010011' => '713', '1110010100' => '714', '1110010101' => '715',
     '1110010110' => '716', '1110010111' => '717', '1110011000' => '718', '1110011001' => '719',
     '1110100000' => '720', '1110100001' => '721', '1110100010' => '722', '1110100011' => '723',
     '1110100100' => '724', '1110100101' => '725', '1110100110' => '726', '1110100111' => '727',
     '1110101000' => '728', '1110101001' => '729', '1110110000' => '730', '1110110001' => '731',
     '1110110010' => '732', '1110110011' => '733', '1110110100' => '734', '1110110101' => '735',
     '1110110110' => '736', '1110110111' => '737', '1110111000' => '738', '1110111001' => '739',
     '1111000000' => '740', '1111000001' => '741', '1111000010' => '742', '1111000011' => '743',
     '1111000100' => '744', '1111000101' => '745', '1111000110' => '746', '1111000111' => '747',
     '1111001000' => '748', '1111001001' => '749', '1111010000' => '750', '1111010001' => '751',
     '1111010010' => '752', '1111010011' => '753', '1111010100' => '754', '1111010101' => '755',
     '1111010110' => '756', '1111010111' => '757', '1111011000' => '758', '1111011001' => '759',
     '1111100000' => '760', '1111100001' => '761', '1111100010' => '762', '1111100011' => '763',
     '1111100100' => '764', '1111100101' => '765', '1111100110' => '766', '1111100111' => '767',
     '1111101000' => '768', '1111101001' => '769', '1111110000' => '770', '1111110001' => '771',
     '1111110010' => '772', '1111110011' => '773', '1111110100' => '774', '1111110101' => '775',
     '1111110110' => '776', '1111110111' => '777', '1111111000' => '778', '1111111001' => '779',
     '1110001010' => '780', '1110001011' => '781', '1110101010' => '782', '1110101011' => '783',
     '1111001010' => '784', '1111001011' => '785', '1111101010' => '786', '1111101011' => '787',
     '1111001110' => '788', '1111001111' => '789', '1110011010' => '790', '1110011011' => '791',
     '1110111010' => '792', '1110111011' => '793', '1111011010' => '794', '1111011011' => '795',
     '1111111010' => '796', '1111111011' => '797', '1111011110' => '798', '1111011111' => '799',
     '0000001100' => '800', '0000001101' => '801', '0100001100' => '802', '0100001101' => '803',
     '1000001100' => '804', '1000001101' => '805', '1100001100' => '806', '1100001101' => '807',
     '0000101110' => '808', '0000101111' => '809', '0000011100' => '810', '0000011101' => '811',
     '0100011100' => '812', '0100011101' => '813', '1000011100' => '814', '1000011101' => '815',
     '1100011100' => '816', '1100011101' => '817', '0000111110' => '818', '0000111111' => '819',
     '0000101100' => '820', '0000101101' => '821', '0100101100' => '822', '0100101101' => '823',
     '1000101100' => '824', '1000101101' => '825', '1100101100' => '826', '1100101101' => '827',
     '0100101110' => '828', '0100101111' => '829', '0000111100' => '830', '0000111101' => '831',
     '0100111100' => '832', '0100111101' => '833', '1000111100' => '834', '1000111101' => '835',
     '1100111100' => '836', '1100111101' => '837', '0100111110' => '838', '0100111111' => '839',
     '0001001100' => '840', '0001001101' => '841', '0101001100' => '842', '0101001101' => '843',
     '1001001100' => '844', '1001001101' => '845', '1101001100' => '846', '1101001101' => '847',
     '1000101110' => '848', '1000101111' => '849', '0001011100' => '850', '0001011101' => '851',
     '0101011100' => '852', '0101011101' => '853', '1001011100' => '854', '1001011101' => '855',
     '1101011100' => '856', '1101011101' => '857', '1000111110' => '858', '1000111111' => '859',
     '0001101100' => '860', '0001101101' => '861', '0101101100' => '862', '0101101101' => '863',
     '1001101100' => '864', '1001101101' => '865', '1101101100' => '866', '1101101101' => '867',
     '1100101110' => '868', '1100101111' => '869', '0001111100' => '870', '0001111101' => '871',
     '0101111100' => '872', '0101111101' => '873', '1001111100' => '874', '1001111101' => '875',
     '1101111100' => '876', '1101111101' => '877', '1100111110' => '878', '1100111111' => '879',
     '0000001110' => '880', '0000001111' => '881', '0100001110' => '882', '0100001111' => '883',
     '1000001110' => '884', '1000001111' => '885', '1100001110' => '886', '1100001111' => '887',
     '0001101110' => '888', '0001101111' => '889', '0000011110' => '890', '0000011111' => '891',
     '0100011110' => '892', '0100011111' => '893', '1000011110' => '894', '1000011111' => '895',
     '1100011110' => '896', '1100011111' => '897', '0001111110' => '898', '0001111111' => '899',
     '0010001100' => '900', '0010001101' => '901', '0110001100' => '902', '0110001101' => '903',
     '1010001100' => '904', '1010001101' => '905', '1110001100' => '906', '1110001101' => '907',
     '0010101110' => '908', '0010101111' => '909', '0010011100' => '910', '0010011101' => '911',
     '0110011100' => '912', '0110011101' => '913', '1010011100' => '914', '1010011101' => '915',
     '1110011100' => '916', '1110011101' => '917', '0010111110' => '918', '0010111111' => '919',
     '0010101100' => '920', '0010101101' => '921', '0110101100' => '922', '0110101101' => '923',
     '1010101100' => '924', '1010101101' => '925', '1110101100' => '926', '1110101101' => '927',
     '0110101110' => '928', '0110101111' => '929', '0010111100' => '930', '0010111101' => '931',
     '0110111100' => '932', '0110111101' => '933', '1010111100' => '934', '1010111101' => '935',
     '1110111100' => '936', '1110111101' => '937', '0110111110' => '938', '0110111111' => '939',
     '0011001100' => '940', '0011001101' => '941', '0111001100' => '942', '0111001101' => '943',
     '1011001100' => '944', '1011001101' => '945', '1111001100' => '946', '1111001101' => '947',
     '1010101110' => '948', '1010101111' => '949', '0011011100' => '950', '0011011101' => '951',
     '0111011100' => '952', '0111011101' => '953', '1011011100' => '954', '1011011101' => '955',
     '1111011100' => '956', '1111011101' => '957', '1010111110' => '958', '1010111111' => '959',
     '0011101100' => '960', '0011101101' => '961', '0111101100' => '962', '0111101101' => '963',
     '1011101100' => '964', '1011101101' => '965', '1111101100' => '966', '1111101101' => '967',
     '1110101110' => '968', '1110101111' => '969', '0011111100' => '970', '0011111101' => '971',
     '0111111100' => '972', '0111111101' => '973', '1011111100' => '974', '1011111101' => '975',
     '1111111100' => '976', '1111111101' => '977', '1110111110' => '978', '1110111111' => '979',
     '0010001110' => '980', '0010001111' => '981', '0110001110' => '982', '0110001111' => '983',
     '1010001110' => '984', '1010001111' => '985', '1110001110' => '986', '1110001111' => '987',
     '0011101110' => '988', '0011101111' => '989', '0010011110' => '990', '0010011111' => '991',
     '0110011110' => '992', '0110011111' => '993', '1010011110' => '994', '1010011111' => '995',
     '1110011110' => '996', '1110011111' => '997', '0011111110' => '998', '0011111111' => '999',
) : ();

# %Math::Decimal128::dpd_decode is simply %Math::Decimal128::dpd_encode
# with the keys and values interchanged.
for my $key(keys(%Math::Decimal128::dpd_encode)) {
  $Math::Decimal128::dpd_decode{$Math::Decimal128::dpd_encode{$key}} = $key;
}

%Math::Decimal128::bid_decode = d128_fmt() eq 'BID' ? (
 0 => MEtoD128('1' . ('0' x 33), 0), 1 => MEtoD128('1' . ('0' x 32), 0),
 2 => MEtoD128('1' . ('0' x 31), 0), 3 => MEtoD128('1' . ('0' x 30), 0),
 4 => MEtoD128('1' . ('0' x 29), 0), 5 => MEtoD128('1' . ('0' x 28), 0),
 6 => MEtoD128('1' . ('0' x 27), 0), 7 => MEtoD128('1' . ('0' x 26), 0),
 8 => MEtoD128('1' . ('0' x 25), 0), 9 => MEtoD128('1' . ('0' x 24), 0),
 10 => MEtoD128('1' . ('0' x 23), 0), 11 => MEtoD128('1' . ('0' x 22), 0),
 12 => MEtoD128('1' . ('0' x 21), 0), 13 => MEtoD128('1' . ('0' x 20), 0),
 14 => MEtoD128('1' . ('0' x 19), 0), 15 => MEtoD128('1' . ('0' x 18), 0),
 16 => MEtoD128('1' . ('0' x 17), 0), 17 => MEtoD128('1' . ('0' x 16), 0),
 18 => MEtoD128('1' . ('0' x 15), 0), 19 => MEtoD128('1' . ('0' x 14), 0),
 20 => MEtoD128('1' . ('0' x 13), 0), 21 => MEtoD128('1' . ('0' x 12), 0),
 22 => MEtoD128('1' . ('0' x 11), 0), 23 => MEtoD128('1' . ('0' x 10), 0),
 24 => MEtoD128('1' . ('0' x 9), 0), 25 => MEtoD128('1' . ('0' x 8), 0),
 26 => MEtoD128('1' . ('0' x 7), 0), 27 => MEtoD128('1' . ('0' x 6), 0),
 28 => MEtoD128('1' . ('0' x 5), 0), 29 => MEtoD128('1' . ('0' x 4), 0),
 30 => MEtoD128('1' . ('0' x 3), 0), 31 => MEtoD128('1' . ('0' x 2), 0),
 32 => MEtoD128('1' . ('0' x 1), 0), 33 => MEtoD128('1', 0)
) : ();

sub _decode_mant {
  my $val = shift;
  my $ret = '';
  for my $i(0 .. 33) {
    my $count = 0;
    if($val > 0) {
      while($val >= $Math::Decimal128::bid_decode{$i}) {
        $val -= $Math::Decimal128::bid_decode{$i};
        $count++;
      }
    }
    $ret .= $count;
  }
  return $ret;
}


sub dl_load_flags {0} # Prevent DynaLoader from complaining and croaking

sub _overload_string {
    my @ret = D128toME($_[0]);
    if(is_InfD128($_[0]) || !$_[0]) {return $ret[0]}
    return $ret[0] . 'e' . $ret[1];
}

sub _overload_int {
    if(is_NaND128($_[0]) || is_InfD128($_[0]) || is_ZeroD128($_[0])) {return $_[0]}
    my($man, $exp) = D128toME($_[0]);
    if($exp >= 0) {return $_[0]}
    my $man_length = length($man);
    $man_length-- if $man =~ /^\-/;
    if(-$exp >= $man_length) {              # -1 <= $_[0] <= 1
       my $z = ZeroD128(1);
       if($_[0] < $z) {return ZeroD128(-1)}  # return -0
       return $z;                           # return  0
    }

    substr($man, $exp, -$exp, '');
    return MEtoD128($man, 0);
}

sub new {

    # This function caters for 2 possibilities:
    # 1) that 'new' has been called OOP style - in which
    #    case there will be a maximum of 2 args
    # 2) that 'new' has been called as a function - in
    #    which case there will be a maximum of 1 arg.
    # If there are no args, then we just want to return a
    # Math::Decimal128 object that's a NaN.

    if(!@_) {return NaND128()}

    if(@_ > 3) {die "More than 3 arguments supplied to new()"}

    # If 'new' has been called OOP style, the first arg is the string
    # "Math::Decimal128" which we don't need - so let's remove it. However,
    # if the first arg is a Math::Decimal128 object (which is a possibility),
    # then we'll get a fatal error when we check it for equivalence to
    # the string "Math::Decimal128". So we first need to check that it's not
    # an object - which we'll do by using the ref() function:
    if(!ref($_[0]) && $_[0] eq "Math::Decimal128") {
      shift;
      if(!@_) {return NaND128()}
      }

    # @_ can now contain max of 2 vals - the mantissa and exponent.
    # If @_ == 1 then it contains the value.
    if(@_ > 2) {die "Too many arguments supplied to new() - expected no more than 2"}

    if(@_ == 2) {return MEtoD128(shift, shift)}

    my $arg = shift;
    my $type = _itsa($arg);

    if($type == 1) { # UV
      return UVtoD128($arg);
    }

    if($type == 2) { # IV
      return IVtoD128($arg);
    }

    if($type == 3) { # NV
      return NVtoD128($arg);
    }

    if($type == 4) { # PV
      return STRtoD128($arg) if have_strtod128();
      return PVtoD128($arg);
    }

    if($type == 34) { # Math::Decimal128 object
      return D128toD128($arg);
    }

    die "Bad argument given to new";
}

sub D128toME {
    my($ret1, $ret2) = split /e/i, decode_d128($_[0]);
    $ret2 = 0 unless defined $ret2;
    $ret2 = 0 if is_ZeroD128($_[0]);
    return ($ret1, $ret2);
}

sub MEtoD128 {
  # Check that 2 args are supplied
  die "MEtoD128 takes 2 args" if @_ != 2;

  my $arg1 = shift;
  my $arg2 = shift;

  die "Invalid 1st arg ($arg1) to MEtoD128" if $arg1 =~ /[^0-9\-]/;
  die "Invalid 2nd arg ($arg2) to MEtoD128" if $arg2 =~ /[^0-9\-]/;

  my $len_1 = length($arg1);
  my $sign = $arg1 =~ /^\-/ ? '-' : '';
  if($sign) {
    $len_1--;
    $arg1 =~ s/^\-//;
  }


  if($len_1 > 34) {
    die "$arg1 exceeds _Decimal128 precision.",
        " It needs to be shortened to no more than 34 decimal digits";
  }

  # split $arg1 into segments that don't exceed 16 digits.

  my($msd, $nsd, $lsd);

  {
  no warnings 'substr';
  $msd = substr($arg1, -34, 10) || '0';
  $nsd = substr($arg1, -24, 12) || '0';
  $lsd = substr($arg1, -12, 12) || '0';
  }

  return _MEtoD128($sign . $msd, $sign . $nsd, $sign . $lsd, $arg2);

}

sub assignMEl {
  # Check that 3 args are supplied
  die "assignMEl takes 3 args" if @_ != 3;

  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;

  die "Invalid 1st arg ($arg1) to assignMEl" if _itsa($arg1) != 34;
  die "Invalid 2nd arg ($arg2) to assignMEl" if $arg2 =~ /[^0-9\-]/;
  die "Invalid 3rd arg ($arg3) to assignMEl" if $arg3 =~ /[^0-9\-]/;

  my $len_2 = length($arg2);
  my $sign = $arg2 =~ /^\-/ ? '-' : '';
  if($sign) {
    $len_2--;
    $arg2 =~ s/^\-//;
  }

  if($len_2 > 34) {
    die "$arg2 exceeds _Decimal128 precision.",
        " It needs to be shortened to no more than 34 decimal digits";
  }

  my($msd, $nsd, $lsd);

  {
  no warnings 'substr';
  $msd = substr($arg2, -34, 10) || '0';
  $nsd = substr($arg2, -24, 12) || '0';
  $lsd = substr($arg2, -12, 12) || '0';
  }

  return _assignME($arg1, $sign . $msd, $sign . $nsd, $sign . $lsd, $arg3);

}

sub _sci2me {
    my @ret = split /e/i, $_[0];
    chop $ret[0] while $ret[0] =~ /0\b/;
    my @adj = split /\./, $ret[0];
    my $adj = defined $adj[1] ? length($adj[1])
                              : 0;
    $ret[0] =~ s/\.//;
    $ret[1] += $_[1] - $adj;

    return @ret;
}

sub DEC128_MAX {return _DEC128_MAX()}
sub DEC128_MIN {return _DEC128_MIN()}

sub d128_bytes {
  my @ret = _d128_bytes($_[0]);
  return join '', @ret;
}

sub hex2binl {
    my $ret = unpack("B*", (pack "H*", $_[0]));
    my $len = length $ret;
    die "hex2binl() yielded $len bits" if $len != 128;
    return $ret;
}

sub d128_fmt {
  my $d128 = MEtoD128('99', 0);
  return 'DPD' if d128_bytes($d128) =~ /000$/;
  return 'BID' if d128_bytes($d128) =~ /063$/;
  return 'Unknown';
}

sub decode_dpdl {
  # Takes the Math::Decimal128 object as its arg.
  # Decodes Densely Packed Decimal formatting of the Decimal128 value.
  my $binstring = hex2binl(d128_bytes($_[0]));
  my @first = decode_dpd_1st($binstring);
  return ($first[0] . $first[1]) if ($first[1] =~ /inf/i || $first[1] =~ /nan/i);
  my $mantissa = $first[1] . decode_dpd_2nd($binstring);

  # Remove leading zeroes from the mantissa
  $mantissa =~ s/^0+//;
  if($mantissa eq '') {$mantissa = '0'}
  else {
    # Remove trailing zeroes
    while($mantissa =~ /0$/) {
      $mantissa =~ s/0$//;
      $first[2]++;
    }
  }

  my $ret = $first[0] . $mantissa . 'e' . $first[2];

}

sub decode_dpd_1st{
  # Takes the entire binary string as its arg.
  die "Argument to decode_dpd_1st is wrong size (", length($_[0]), ")"
    if length($_[0]) != 128;
  my $leading_bits = 18;
  my $trailing_bits = 110;
  my $msd;                  # significand's most siginificant digit
  my $exp;                  # exponent
  my $keep = substr($_[0], 0, $leading_bits);
  my $sign = substr($keep, 0, 1) ? '-' : '';
  return ('','nan') if substr($keep, 1, 5) eq '11111';
  if(substr($keep, 1 ,5) eq '11110') {return ($sign, 'inf')}
  my $pre = substr($keep, 1, 2);
  if($pre eq '00' || $pre eq '01' || $pre eq '10') {
    $msd = oct('0b0' . substr($keep, 3, 3));
    $exp = oct('0b' . $pre . substr($keep, 6, 12)) - 6176;
    return ($sign, $msd, $exp);
  }
  $pre = substr($keep, 1, 4);
  if($pre eq '1100' || $pre eq '1101' || $pre eq '1110') {
    $exp = oct('0b' . substr($pre, 2, 2) . substr($keep, 6, 12)) - 6176;
    $msd = oct('0b' .  '100' . substr($keep, 5, 1));
    return ($sign, $msd, $exp);
  }
  die "decode_dpd_1st function failed to parse its argument ($_[0])";
}

sub decode_dpd_2nd {
  # Takes the entire binary string as its arg.
  die "Argument to decode_dpd_2nd is wrong size (", length($_[0]), ")"
    if length($_[0]) != 128;
  my $leading_bits = 18;
  my $trailing_bits = 110;
  my $keep = substr($_[0], $leading_bits, $trailing_bits);
  my $ret = '';
  for my $i(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100) {
    my $key = substr($keep, $i, 10);
    $ret .= $Math::Decimal128::dpd_encode{$key};
  }
  return $ret;
}

sub decode_bidl {
  # Takes a Math::Decimal128 object as its arg.
  # Decodes Binary Integer Decimal formatting of the _Decimal128 value.

  my $keep = hex2binl(d128_bytes($_[0]));
  die "Base 2 representation is wrong size (", length($keep), ")"
    if length($keep) != 128;
  my $leading_bits =  17;
  my $trailing_bits = 111;
  my @mantissa;
  my $exp;                  # exponent
  my $sign = substr($keep, 0, 1) ? '-' : '';
  return 'nan' if substr($keep, 1, 5) eq '11111';
  if(substr($keep, 1 ,5) eq '11110') {return $sign . 'inf'}
  my $pre = substr($keep, 1, 2);
  if($pre eq '00' || $pre eq '01' || $pre eq '10') {
    $exp = oct('0b' . substr($keep, 1, 14)) - 6176;
    @mantissa =  reverse(split(//, '0' . substr($keep, 15, 113)));
    my $m = _bid_mant(\@mantissa); # $m is a Math::Decimal128 object
    my $mantissa = _decode_mant($m);
    $mantissa =~ s/^0+//;
    if($mantissa !~ /[1-9]/) { $mantissa = '0'}
    else {
      while($mantissa =~ /0$/) {
        $mantissa =~ s/0$//;
        $exp++;
      }
    }
    return $sign . $mantissa . 'e' . $exp;
  }
  $pre = substr($keep, 1, 4);
  if($pre eq '1100' || $pre eq '1101' || $pre eq '1110') {
    $exp = oct('0b' . substr($keep, 3, 14)) - 6176;
    @mantissa = reverse(split(//,'100' . substr($keep, 17, 111)));
    my $m = _bid_mant(\@mantissa); # $m is a Math::Decimal128 object
    my $mantissa = _decode_mant($m);
    $mantissa =~ s/^0+//;
    if($mantissa !~ /[1-9]/) { $mantissa = '0'}
    else {
      while($mantissa =~ /0$/) {
        $mantissa =~ s/0$//;
        $exp++;
      }
    }
    return $sign . $mantissa . 'e' . $exp;
  }
  die "decode_bid function failed to parse its argument ($_[0])";
}

sub PVtoD128 {
  my($arg1, $arg2) = split /e/i, $_[0];
  $arg2 = 0 unless defined $arg2;
  my @split = split /\./, $arg1;
  $split[1] = '' unless defined $split[1];
  $arg2 -= length($split[1]);
  $arg1 =~ s/\.//;
  $arg1 =~ s/^0+//;
  return MEtoD128($arg1, $arg2);
}

sub get_expl {
  my $keep = hex2binl(d128_bytes($_[0]));
  my $pre = substr($keep, 1, 2);
  if(d128_fmt() eq 'DPD') {
    if($pre eq '00' || $pre eq '01' || $pre eq '10') {
      return oct('0b' . $pre . substr($keep, 6, 12)) - 6176;
    }
    else {
      return oct('0b' . substr($pre, 2, 2) . substr($keep, 6, 12)) - 6176;
    }
  }
  else {
    if($pre eq '00' || $pre eq '01' || $pre eq '10') {
      return oct('0b' . substr($keep, 1, 14)) - 6176;
    }
    else {
      return oct('0b' . substr($keep, 3, 14)) - 6176;
    }
  }
}

sub get_signl {
  return '-' if hex(substr(d128_bytes($_[0]), 0, 1)) >= 8;
  return '+';
}

sub DPDtoD128 {
  # Usable only where DPD format is in use.
  # Converts the 128-bit string returned by _MEtoBINSTR into
  # a Math::Decimal128 object set to the value encoded by the
  # the 128-bit string. This is all done without having to calculate
  # the actual value - and is typically ~25 times quicker than
  # MEtoD128.
  my($man, $exp) = (shift, shift);
  my $arg = _MEtoBINSTR($man, $exp);
  return _DPDtoD128(unpack("a*", pack( "B*", $arg)));
}

sub _MEtoBINSTR {
  # Converts (mantissa, exponent) strings to DPD encoded 128-bit string - without
  # the need to actually calculate the value.
  my($man, $exp) = (shift, shift);
  if($man =~ /^(\-|\+)?inf/i) {
     $man =~ /\-inf/ ? return '11111' . ('0' x 123)
                     : return '01111' . ('0' x 123);
  }
  if($man =~ /^(\-|\+)?nan/i) { return '011111' . ('0' x 122) }

  # Determine the sign, and remove it.
  my $sign = $man =~ /^\-/ ? '1' : '0';
  $man =~ s/[\+\-]//;
  die "_MEtoBINSTR has been passed (probably from DPDtoBINSTR) an illegal mantissa"
    if $man =~ /[^0-9]/;

  # Fill the mantissa with 34 digits - by zero padding the end.
  my $add_zeroes = 34 - length($man);
  $man .= '0' x $add_zeroes;
  $exp -= $add_zeroes;

  # The last 110 bits encode the last 33 digits.
  my $last_33_dig = substr($man, 1, 33);
  my $last_110_bits;
  for(my $i = 0; $i < 31; $i += 3) {
    $last_110_bits .= $Math::Decimal128::dpd_decode{substr($last_33_dig, $i, 3)}
  }

  my $len = length($last_110_bits);
  die "Wrong bitsize ($len != 110) in MEtoBINSTR()" if $len != 110;

  my $leading_digit = substr($man, 0, 1); # ie the msd (most siginificant digit).
  my $exp_base_2 = sprintf "%014b", $exp + 6176;

  # The encoding of the exponent and msd depends upon the value of the msd.
  # If it's 0..7, it's done one way; if it's 8 or 9 it's done th'other way.
  if($leading_digit < 8) {
    my $leading_digit_bits = sprintf "%03b", $leading_digit;
    substr($exp_base_2, 2, 0, $leading_digit_bits);
  }
  else {
    my $leading_digit_bit = $leading_digit == 8 ? '0' : '1';
    $exp_base_2 = '11' . substr($exp_base_2, 0, 2) . $leading_digit_bit . substr($exp_base_2, 2, 12);
  }

  $len = length($exp_base_2);
  die "Exponent component length is wrong ($len != 17) in MEtoBINSTR()" if $len != 17;

  return $sign . $exp_base_2 . $last_110_bits;
}

*decode_d128 = d128_fmt() eq 'DPD' ? \&decode_dpdl : \&decode_bidl;

1;

__END__

=head1 NAME

Math::Decimal128 - perl interface to C's _Decimal128 operations.

=head1 DEPENDENCIES

   In order to compile this module, a C compiler that provides
   the _Decimal128 type is needed.

=head1 DESCRIPTION

   Math::Decimal128 supports up to 34 decimal digits of significand
   (mantissa) and an exponent range of -6143 to +6144.
   The smallest expressable value is
     -9.999999999999999999999999999999999e6144 which is also
   equivalent to
     -9.999999999999999999999999999999999e6111.
   The largest expressable value is
     9.999999999999999999999999999999999e6144 which is also
   equivalent to
     9.999999999999999999999999999999999e6111.
   The closest we can get to zero is (plus or minus) 1e-6176
   (which is also equivalent to
     1000000000000000000000000000000000e-6143).

   This module allows decimal floating point arithmetic via
   operator overloading - see "OVERLOADING".

   In the documentation that follows, "$mantissa" is a perl scalar
   holding a string of up to 16 decimal digits:
    $mantissa = '1234';
    $mantissa = '1234567890123456';

=head1 SYNOPSIS

   use Math::Decimal128 qw(:all);

   my $d128_1 = MEtoD128('9927', -2); # the decimal 99.27
   my $d128_2 = MEtoD128('3', 0);     # the decimal 3.0
   $d128_1 /= $d128_2;
   print $d128_1; # prints 3309e-2 (33.09)

=head1 OVERLOADING

   The following operations are overloaded:
    + - * /
    += -= *= /=
    != == <= >= <=> < >
    ++ --
    =
    abs bool int print

    Arguments to the overloaded operations must be Math::Decimal128
    objects or integer (IV/UV) values.

     $d128_2 = $d128_1 + 15; # ok

     $d128_2 = $d128_1 + 3.1; # Error. Best to either:
     $d128_2 = $d128_1 + MEtoD128('31',-1); # or (equivalentally):
     $d128_2 = $d128_1 + Math::Decimal128->new('31',-1);

=head1 CREATION & ASSIGNMENT FUNCTIONS

    The following create and assign a new Math::Decimal128 object.

     ###################################
     # Assign from mantissa and exponent
     $d128 = MEtoD128($mantissa, $exponent);

      eg: $d128 = MEtoD128('12345', -3); # 12.345

      It's a little kludgy, but this is the safest and surest way
      of creating the Math::Decimal128 object with the intended
      value.
      Checks are conducted to ensure that the arguments are suitable.
      The mantissa string must represent an integer.

     ###################################
     # Assign from mantissa and exponent more efficiently
     # NOTE: This works correctly only with DPD format.
     $d128 = DPDtoD128($mantissa, $exponent);

      eg: $d128 = DPDtoD128('12345', -3); # 12.345

      This is the quickest way of creating the Math::Decimal128 object
      with the intended value - but works only for DPD format - ie
      only if d128_fmt() returns 'DPD'.
      The mantissa string can be 'inf' or 'nan', optionally prefixed
      with '-' or '+'. Otherwise, the mantissa string must
      represent an integer value - ie cannot contain a decimal point.

     ######################
     # Assign from a string
     $d128 = PVtoD128($string);

      eg: $d128 = PVtoD128('-9427199254740993');
          $d128 = PVtoD128('-930719925474.0993e-15');
          $d128 = Math::Decimal128->new('-978719925474.0993');
          $d128 = Math::Decimal128->new('-9307199254740993e-23');

      Transforms the string into args suitable for MEtoD128(),
      then uses that function to create the Math::Decimal128 object.

     #####################################
     # Assign from a UV (unsigned integer)
     $d128 = UVtoD128($uv);

      eg: $d128 = UVtoD128(~0);

      Doing Math::Decimal128->new($uv) will also create and assign
      using UVtoD128().
      Assigns the UV value to the Math::Decimal128 object.

     ####################################
     # Assign from an IV (signed integer)
     $d128 = IVtoD128($iv);

      eg: $d128 = IVtoD128(-15); # -15.0

      Doing Math::Decimal128->new($iv) will also create and assign
      using IVtoD128().
      Assigns the UV value to the Math::Decimal128 object.

     ################################################
     # Assign from an existing Math::Decimal128 object
     $d128 = D128toD128($d128_0);
     Also:
      $d128 = Math::Decimal128->new($d128_0);
      $d128 = $d128_0; # uses overloaded '='

     ###########################
     # Assign from an NV (real))
     $d128 = NVtoD128($nv);

      eg: $d128 = NVtoD128(-3.25);

      Doing Math::Decimal128->new($nv) will also create and assign
      using NVtoD128().
      Might not always assign the value you think it does. (Eg,
      see test 5 in t/overload_cmp.t.)

     ####################
     # Assign using new()
     $d128 = Math::Decimal128->new([$arg1, [$arg2]]);
      This function calls one of the above functions. It
      determines the appropriate function to call by examining
      the argument(s) provided.
      If no argument is provided, a Math::Decimal128 object
      with a value of NaN is returned.
      If 2 arguments are supplied it uses MEtoD128().
      If one argument is provided, that arg's internal flags are
      used to determine the appropriate function to call.

     #######################
     # Assign using STRtoD128
     $d128 = STRtoD128($string);
      If your C compiler provides the strtod128 function &&
      you configured the Makefile.PL to enable access to that
      function then you can use this function.
      usage is is as for PVtoD128().

     ##############################

=head1 ASSIGN A NEW VALUE TO AN EXISTING OBJECT

     assignMEl($d128, $mantissa, $exponent);
      Assigns the value represented by ($mantissa, $exponent)
      to the Math::Decimal128 object, $d128.

      eg: assignMEl($d128, '123459', -6); # 0.123459

     assignPV($d128, $string);
      Assigns the value represented by $string to the
      Math::Decimal128 object, $d128.

      eg: assignPV($d128, '123459e-6'); # 0.123459

     assignNaN($d128);
      Assigns a NaN to the Math::Decimal128 object, $d128.

     assignInf($d128, $sign);
      Assigns an Inf to the Math::Decimal128 object, $d128.
      If $sign is negative, assigns -Inf; otherwise +Inf.

=head1 INF, NAN and ZERO OBJECTS

     $d128 = InfD128($sign);
      If $sign < 0, creates a new Math::Decimal128 object set to
      negative infinity; else creates a Math::Decimal128 object set
      to positive infinity.

     $d128 = NaND128();
      Creates a new Math::Decimal128 object set to NaN.
      Same as "$d128 = Math::Decimal128->new();"

     $d128 = ZeroD128($sign);
      If $sign < 0, creates a new Math::Decimal128 object set to
      negative zero; else creates a Math::Decimal128 object set to
      zero.

=head1 RETRIEVAL FUNCTIONS

    The following functions provide ways of seeing the value of
    Math::Decimal128 objects.

     $string = decode_d128($d128);
      This function calls either decode_dpd() or decode_bid(),
      depending upon the formatting used to encode the
      _Decimal128 value (as determined by the d128_fmt() sub).
      It returns the value as a string of the form (-)ME, where:
       "M" is the mantissa, containing up to 34 base 10 digits;
       "E" is the letter "e" followed by the exponent;
       A minus sign is prefixed to any -ve number (incl -0), but no
       sign at all is prefixed for +ve numbers (incl +0).
      Returns the strings '+inf', '-inf', 'nan' for (respectively)
      +infinity, -infinity, NaN.
      The value will be decoded correctly.

     $string = decode_dpd($d128_binary);
     $string = decode_bid($d128_binary);

      As for decode_d128(), except it takes the 128-bit binary
      representation of the _Decimal128 value as its argument. This
      argument is derived from the Math::Decimal128 object ($d128)
      by doing:
        $binary = hex2bin(d128_bytes($d128));
      DPD and BID formats will return different strings - so you
      need to know which encoding (DPD or BID) was used, and then
      call the appropriate decode_*() function for that encoding.
      The d128_fmt() sub will tell you which encoding is in use.

     ($mantissa, $exponent) = D128toME($d128);
      Returns the value of the Math::Decimal object as a
      mantissa (string of up to 34 decimal digits) and exponent.
      You can then manipulate those values to output the
      value in your preferred format.

     $nv = D128toNV($d128);
      This function returns the value of the Math::Decimal128
      object to a perl scalar (NV). It will not translate the value
      accurately if the precision required to express the value
      precisely as a _Decimal128 value is greater than the precision
      provided by the NV.

     print $d128;
      Will print the value in the format (eg) -12345e-2, which
      equates to the decimal -123.45. Uses D128toME().

=head1 OTHER FUNCTIONS

     $fmt = d128_fmt();
      Returns either 'DPD' or 'BID', depending upon whether the
      (internal) _Decimal128 values are encoded using the 'Densely
      Packed Decimal' format or the 'Binary Integer Decimal'
      format.

     $hex = d128_bytes($d128);
      Returns the hex representation of the _Decimal128 value
      as a string of 32 hex characters.

     $binary = hex2bin($d128_hex);
      Takes the string returned by d128_bytes (above) and
      rewrites it in binary form - ie as a string of 128 base 2
      digits.

     $d128 = DEC128_MAX; # 9999999999999999999999999999999999e6111
     $d128 = DEC128_MIN; # 1e-6176
      DEC128_MAX is the largest positive finite representable
      _Decimal128 value.
      DEC128_MIN is the smallest positive non-zero representable
      _Decimal128 value.
      Multiply these by -1 to get their negative counterparts.

     $d128 = Exp10l($pow);
      Returns a Math::Decimal128 object with a value of
      10 ** $pow, for $pow in the range (-6176 .. 6144). Croaks
      with appropriate message if $pow is not within that range.

     $bool = have_strtod128();
      Returns true if, when building Math::Decimal128,
      the Makefile.PL was configured to make the STRtoD128()
      function available for your build of Math::Decimal128. Else
      returns false.
      (No use making this function available if your compiler's
      C library doesn't provide the strtod128 function.)


     $test = is_ZeroD128($d128);
      Returns:
       -1 if $d128 is negative zero;
        1 if $d128 is a positive zero;
        0 if $d128 is not zero.

     $test = is_InfD128($d128);
      Returns:
       -1 if $d128 is negative infinity;
        1 if $d128 is positive infinity;
        0 if $d128 is not infinity.

     $bool = is_NaND128($d128);
      Returns:
        1 if $d128 is a NaN;
        0 if $d128 is not a NaN.

     $sign = get_signl($d128);
      Returns the sign ('+' or '-') of $d128.

     $exp = get_expl($d128);
      Returns the exponent of $d128. This is the value that's
      stored internally within the encapsulated _Decimal128 value;
      it may differ from the value that you assigned. For example,
      if you've assigned the value MEtoD128('100', 0) it will
      probably be held internally as '1e2', not '100e0'.

=head1 LICENSE

    This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.
    Copyright 2014 Sisyphus

=head1 AUTHOR

    Sisyphus <sisyphus at(@) cpan dot (.) org>

=cut



